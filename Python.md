# Подготовка к собеседованию по Python

## Оглавление
* [Python](#Python)
* [Типы данных](#Типы-данных)
    * [Последовательности](#Последовательности)
    * [Хэш таблица](#Хэш-таблица)
* [Итераторы](#Итераторы)
* [Генераторы](#Генераторы)
* [Контекстный менеджер](#Контекстный-менеджер)
* [Функции](#Функции)
    * [args и kwargs](#args-и-kwargs)
    * [Хвостовая рекурсия](#Хвостовая-рекурсия)
    * [Lambda](#Lambda)
* [Декораторы](#Декораторы)
    * [Популярные декораторы](#Популярные-декораторы)
* [Исключения](#Исключения)
* [ООП](#ООП)
    * [Магические методы](#Магические-методы)
    * [Наследование](#Наследование)
* [Дескрипторы](#Дескрипторы)
* [Метаклассы](#Метаклассы)
* [Память](#Память)
* [GIL](#GIL)
* [Модули/пакеты](#Модули/пакеты)
* [Итерпритатор](#Итерпритатор)
* [Либы](#Либы)
* [Линтеры и аннотация типов](#Линтеры-и-аннотация-типов)
* [Источники](#Источники)

## Python
[Go Back](#оглавление)
* Это императивный ЯП с динамичесой типизацией, который поддерживает парадигму ООП и немного может в функциональное программирование
* Все в Python - это объекты
* Это интерпритируемый ЯП
* Easy to start - hard to master (личное мнение)
## Типы данных
[Go Back](#оглавление)
* Неизменяемые
  * Числовые
      * Целочисленные
      * С плавающей точкой
      * Комплексные
  * Логические (boolean)
  * Последовательности
      * Строка
          * Функции `encode()` `decode()` предназначены для работы с байтстроками
      * Кортеж
      * Frozen Set
* Изменяемые - созданные объекты могут быть изменены или дополнены
  * Последовательности
      * Словари
          * Ключом словаря может быть **любой** неизменяемый объект
          * `items()`, `keys()` и `values()` возвращают соотвтсвующие объекты словаря в виде последовательности
      * Списки
      * Множества
          * Представляют собой последовательность с уникальными элементами
### Последовательности 
* Последовательностью в Python называется итерабельный объект, который поддерживает эффективный доступ к элементам с использованием целочисленных индексов через специальный метод `__getitem__()` и поддерживает метод `__len__()`
* Последовательности также опционально могут реализовывать методы `count()`, `index()`, `__contains__()` и `__reversed__()` и другие
* Две последовательности равны, если они имеют одинаковый тип, равную длину и соответствующие элементы обоих последовательностей равны
#### Диапазоны
* Диапазоны – неизменяемые последовательности чисел, которые задаются началом, концом и шагом
* `range(1, 10, 2)`
### Хэш таблица
* Хэш-таблица это разреженный массив (массив, в котором имеются незаполненные позиции)
* В хэш-таблице dict каждому элементу соотвествует ячейка, содержащая два поля: ссылку на ключ и ссылку на значение элемента
* Поскольку размер всех ячеек одинаков, доступ к отдельной ячейке производится по смещению
* Для помещения элемента в хэш-таблицу нужно первым делом вычислить хэш-значение ключа элемента. Это делает встроенная функция `hash()`
* Хэш-функции — это функции, получающие на входе данные, обычно строку, и возвращающие число. При многократном вызове хэш-функции с одинаковыми входными данными она всегда будет возвращать одно и то же число, и возвращаемое число всегда будет находиться в гарантированном интервале. Этот интервал зависит от хэш-функции: в некоторых используются 32-битные целочисленные значения (то есть от 0 до 4 миллиардов), в других интервалы гораздо больше
    * Коллизия - когда два разных входных значения дают одно значение на выходе
* Доступ к данным хэш таблицы происходят за О(1)
* Хэш таблица применяется при формировании _Dict, Set, Frozen Set_
## Итераторы
[Go Back](#оглавление)
* Итерабельный объект – это объект, который возвращает свои элементы по одному за раз
    * В них определён метод `__iter__()` или `__getitem__()`
* `__iter__()` - возвращает объект, который может быть использован для итеррации по элементам
    * Такой объект обязан иметь метод `__next__()`
* Повторяемый вызов метода `__next__()` итератора или передача его встроенной функции `next()` возвращает последующие элементы потока
* Если больше не осталось данных, выбрасывается исключение _StopIteration_. После этого итератор исчерпан и любые последующие вызовы его метода `__next__()` снова генерируют исключение _StopIteration_
* Обязан иметь метод `__iter__`, который возвращает сам объект итератора, так что любой итератор также является итерабельным объектом и может быть использован почти везде, где принимаются итерабельные объекты
* Может быть написан с помощью генератора
* Используется для прохода по всем значениям коллекции
## Генераторы
[Go Back](#оглавление)
* В зависимости от контекста, может означать либо функцию-генератор, либо итератор генератора (чаще всего, последнее). Методы `__iter__` и `__next__` у генераторов создаются автоматически
    * Из-за этого в Python любой генератор является итератором
* Создает последовательности (возвращает итератор)
* Как создать генератор
    * `(x for x in seq)`
    * `yield` в теле функции вместо `return`
### Генераторные функции
* Функция, в теле которой встречается ключевое слово `yield`
* `yield` замораживает состояние функции-генератора и возвращает текущее значение. После следующего вызова `__next__()` функция-генератор продолжает своё выполнение с того места, где она была приостановлена
### Генераторы последовательностей
* Генератором можно удобно создавать списки или словари
* Генератор списков пример: `[i**2 for i in a if i != 2]`
* Генератор словаря пример: `{k: v for k, v in zip(keys, values)}`
## Контекстный менеджер
[Go Back](#оглавление)
* Контекстный менеджер - объект, который определяет логику входа и выхода в блок кода внутри этого объекта
* События входа и выхода из блока определены методами `__enter__` и `__exit__`
* `with` - гарантирует что будет выполнен вход и выход из того, что внутри оператора
* Пример контекстного менеджера - класс, порожденный функцией `open`. Он гарантирует, что файл будет закрыт даже в том случае, если внутри блока возникнет ошибка
## Функции
[Go Back](#оглавление)
* Аргументы в функции передаются в виде ссылок на объекты
   * Это значит, что изменяемые объекты могут быть изменены изнутри функции
* Аргументы функции могут быть заданы по-умолчанию
   * При этом стоит избегать делать такими аргументами изменяемые объекты
### args и kwargs
* Выражения `*args` и `**kwargs` объявляют в сигнатуре функции
* Они означают, что внутри функции будут доступны переменные с именами `args` и `kwargs` (без звездочек)
* `args` – это кортеж, который накапливает позиционные аргументы
* `kwargs` – словарь именованных аргументов, где ключ – имя параметра, значение – значение параметра
* Если в функцию не передано никаких параметров, переменные будут соответственно равны пустому кортежу и пустому словарю, а не `None`
### Хвостовая рекурсия
* Это особый вид рекурсии, когда функция заканчивается вызовом самой себя без дополнительных операторов, тем самым не забивая стэк
* Итерпритатор Python не умеет оптимизировать хвостовую рекурсию, поэтому обычно её заменяют другими механизмами, например циклами или обычной рекурсией
### Lambda
* Анонимная функция - не занимает место в пространстве имен
* Определяется одной строкой без использования ключевого слова `def`, но с помощью `lambda`
* Пример `val = lambda x: x * 2 + 1`
## Декораторы
[Go Back](#оглавление)
* https://habr.com/ru/articles/141411/
* https://habr.com/ru/articles/141501/
* Декоратор - паттерн проектирования, когда один объект изменяет поведение другого
* Декоратором может быть любой вызываемый объект: функция, лямбда, класс, экземпляр класса. В последнем случае определите метод `__call__`
### Популярные декораторы
* `@classmethod`
    * Позволяет функции использовать атрибуты класса, а не атрибуты экземпляра класса в котором был вызван
* `@staticmethod`
    * Функция, которая ничего не знает о классе или экземпляре класса и может быть вызвана без инициализации класса
* `@property`
    * Позволяет выстроить корректную инкапсуляцию в классе
    * Позволяет определить `getter`, `setter`, `deleter`
## Исключения
[Go Back](#оглавление)
* Обработка исключений — механизм, предназначенный для описания реакции программы на ошибки во время выполнения и другие возможные проблемы (исключения)
* Пример кода
```python
try:
    1/0
except ZeroDivisionError:
    print("why?")
else:
    print("ok")
finally:
    raise Exception("...")
```
* `try` пытается выполнить определенный кусок кода
* `except` попытается отловить указанную ошибку
* `else` выполниться, если не будет выполнен блок `except`
* `finally` выполнится в конце
* `raise` сгенерирует исключение (остановит выполнение программы) 
## ООП
[Go Back](#оглавление)
* Python придерживается основных парадигм ООП - абстракция, наследование, полиморфизм, инкапсуляция
* Однако инкапсуляция условная
```python
class A:
   _a = 1   # protected
   __b = 2  # private

A()._a     # не выдаст ошибку
A().__b    # а это уже ошибка 
A()._A__b  # опять не выдаст ошибку
```
### Магические методы
* Магическими метода называют методы, имена которых начинаются и заканчиваются двойным подчеркиванием
* Магические они потому, что почти никогда не вызываются явно. Их вызывают встроенные функции или синтаксические конструкции. Например, функция `len()` вызывает метод `__len__()`
### Наследование
* Для обращение к родительскому классу нужно использовать ключевое слово `super`
* MRO – method resolution order, порядок разрешения методов. Алгоритм, по которому следует искать метод в случае, если у класса два и более родителей
    * Сначала экземпляр
    * Затем его класс
    * Далее все суперклассы его класса с обходом сначала с глубину, а затем слева направо
## Дескрипторы
[Go Back](#оглавление)
* Это способ, с помощью которого объект может контролировать доступ к его атрибутам, используя специально определенные методы `__get__`, `__set__`, и `__delete__`
* `property` как раз работает как дескриптор 
## Метаклассы
[Go Back](#оглавление)
* Метаклассы - классы, создающие классы
* `type` - это метакласс, который Питон внутренне использует для создания всех классов
## Память (сборщик мусора)
[Go Back](#оглавление)

## GIL
[Go Back](#оглавление)
* В любой момент может выполняться только один поток Python
* Глобальная блокировка интерпретатора — GIL — тщательно контролирует выполнение тредов
* GIL гарантирует каждому потоку эксклюзивный доступ к переменным интерпретатора (и соответствующие вызовы C-расширений работают правильно)
* Принцип работы прост. Потоки удерживают GIL, пока выполняются. Однако они освобождают его при блокировании для операций ввода-вывода. Каждый раз, когда поток вынужден ждать, другие, готовые к выполнению, потоки используют свой шанс запуститься
* Когда поток начинает работу, он выполняет захват GIL. Спустя какое-то время планировщик процессов решает, что текущий поток поработал достаточно, и передает управление следующему потоку. Поток №2 видит, что GIL захвачен, так что он не продолжает работу, а погружает себя в сон, уступая процессор потоку №1
* В поздних версиях GIL может быть удержан потоком не дольше 5 мс. GIL так-же освобождается, если поток совершает системный вызов, работает с диском или сетью
## Модули/пакеты
[Go Back](#оглавление)

## Итерпритатор
[Go Back](#оглавление)

## Либы 
(async, pandas, numpy, pytest, django)
[Go Back](#оглавление)

## Линтеры и аннотация типов 
(pep8)
[Go Back](#оглавление)

## Источники
[Go Back](#оглавление)
* https://github.com/yakimka/python_interview_questions/blob/master/questions.md/#Python
* https://habr.com/ru/companies/ruvds/articles/747084/
* https://habr.com/ru/companies/otus/articles/801595/
