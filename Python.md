# Подготовка к собеседованию по Python

## Оглавление
* [Python](#Python)
* [Типы данных](#Типы-данных)
    * [Последовательности](#Последовательности)
    * [Хэш таблица](#Хэш-таблица)
* [Итераторы](#Итераторы)
* [Генераторы](#Генераторы)
* [Контекстный менеджер](#Контекстный-менеджер)
* [Функции](#Функции)
* [Декораторы](#Декораторы)
    * [Популярные дефолтные декораторы](#Популярные-дефолтные-декораторы)
* [Исключения](#Исключения)
* [ООП](#ООП)
* [Дескрипторы](#Дескрипторы)
* [Метаклассы](#Метаклассы)
* [Память](#Память)
* [Gil](#Gil)
* [Модули/пакеты](#Модули/пакеты)
* [Итерпритатор](#Итерпритатор)
* [Либы](#Либы)
* [Линтеры и аннотация типов](#Линтеры-и-аннотация-типов)
* [Источники](#Источники)

## Python
[Go Back](#оглавление)
* Это императивный ЯП с динамичесой типизацией, который поддерживает парадигму ООП и немного может в функциональное программирование
* Все в Python - это объекты
* Это интерпритируемый ЯП
* Easy to start - hard to master (личное мнение)
## Типы данных
[Go Back](#оглавление)
* Неизменяемые
  * Числовые
      * Целочисленные
      * С плавающей точкой
      * Комплексные
      * Логические (boolean)
  * Последовательности
      * Строка
          * Функции `encode()` `decode()` предназначены для работы с байтстроками
      * Кортеж
      * Frozen Set
* Изменяемые - созданные объекты могут быть изменены или дополнены
  * Последовательности
      * Словари
          * Ключом словаря может быть **любой** неизменяемый объект
          * `items()`, `keys()` и `values()` возвращают соотвтсвующие объекты словаря в виде последовательности
      * Списки
      * Множества
          * Представляют собой последовательность с уникальными элементами
### Последовательности 
* Последовательностью в Python называется итерабельный объект, который поддерживает эффективный доступ к элементам с использованием целочисленных индексов через специальный метод `__getitem__()` и поддерживает метод `__len__()`
* Последовательности также опционально могут реализовывать методы `count()`, `index()`, `__contains__()` и `__reversed__()` и другие
* Две последовательности равны, если они имеют одинаковый тип, равную длину и соответствующие элементы обоих последовательностей равны
#### Диапазоны
* Диапазоны – неизменяемые последовательности чисел, которые задаются началом, концом и шагом
* `range(1, 10, 2)`
### Хэш таблица
* Хэш-таблица это разреженный массив (массив, в котором имеются незаполненные позиции)
* В хэш-таблице dict каждому элементу соотвествует ячейка, содержащая два поля: ссылку на ключ и ссылку на значение элемента
* Поскольку размер всех ячеек одинаков, доступ к отдельной ячейке производится по смещению
* Для помещения элемента в хэш-таблицу нужно первым делом вычислить хэш-значение ключа элемента. Это делает встроенная функция `hash()`
* Хэш-функции — это функции, получающие на входе данные, обычно строку, и возвращающие число. При многократном вызове хэш-функции с одинаковыми входными данными она всегда будет возвращать одно и то же число, и возвращаемое число всегда будет находиться в гарантированном интервале. Этот интервал зависит от хэш-функции: в некоторых используются 32-битные целочисленные значения (то есть от 0 до 4 миллиардов), в других интервалы гораздо больше
    * Коллизия - когда два разных входных значения дают одно значение на выходе
* Доступ к данным хэш таблицы происходят за О(1)
* Хэш таблица применяется при формировании _Dict, Set, Frozen Set_
## Итераторы
[Go Back](#оглавление)
* Итерабельный объект – это объект, который может возвращать значения по одному за раз
* В них определён метод `__iter__()` или `__getitem__()`
* Итератор (iterator) – это объект, который представляет поток данных. Повторяемый вызов метода `__next__()` итератора или передача его встроенной функции `next()` возвращает последующие элементы потока
* Если больше не осталось данных, выбрасывается исключение _StopIteration_. После этого итератор исчерпан и любые последующие вызовы его метода `__next__()` снова генерируют исключение _StopIteration_
* Итераторы обязаны иметь метод `__iter__`, который возвращает сам объект итератора, так что любой итератор также является итерабельным объектом и может быть использован почти везде, где принимаются итерабельные объекты
## Генераторы
[Go Back](#оглавление)
* В зависимости от контекста, может означать либо функцию-генератор, либо итератор генератора (чаще всего, последнее). Методы `__iter__` и `__next__` у генераторов создаются автоматически
* В Python любой генератор является итератором
* Как создать генератор
    * `(x for x in seq)`
    * `yield` в теле функции вместо `return`
### Генераторные функции
* Функция, в теле которой встречается ключевое слово `yield`
* `yield` замораживает состояние функции-генератора и возвращает текущее значение. После следующего вызова `__next__()` функция-генератор продолжает своё выполнение с того места, где она была приостановлена
### Генераторы последовательностей
* Генератором можно удобно создавать списки или словари
* Генератор списков пример: `[i**2 for i in a if i != 2]`
* Генератор словаря пример: `{k: v for k, v in zip(keys, values)}`
## Контекстный менеджер
[Go Back](#оглавление)
* Контекстный менеджер - объект, который определяет логику входа и выхода в блок кода внутри этого объекта
* События входа и выхода из блока определены методами `__enter__` и `__exit__`
* `with` - гарантирует что будет выполнен вход и выход из того, что внутри оператора
* Пример контекстного менеджера - класс, порожденный функцией `open`. Он гарантирует, что файл будет закрыт даже в том случае, если внутри блока возникнет ошибка
## Функции
* Аргументы в функции передаются в виде ссылок на объекты
   * Это значит, что изменяемые объекты могут быть изменены изнутри функции
* Аргументы функции могут быть заданы по-умолчанию
   * При этом стоит избегать делать такими аргументами изменяемые объекты
### *args, **kwargs
* Выражения `*args` и `**kwargs` объявляют в сигнатуре функции
* Они означают, что внутри функции будут доступны переменные с именами `args` и `kwargs` (без звездочек)
* `args` – это кортеж, который накапливает позиционные аргументы
* `kwargs` – словарь именованных аргументов, где ключ – имя параметра, значение – значение параметра
* Если в функцию не передано никаких параметров, переменные будут соответственно равны пустому кортежу и пустому словарю, а не `None`
### Хвостовая рекурсия
* Это особый вид рекурсии, когда функция заканчивается вызовом самой себя без дополнительных операторов, тем самым не забивая стэк
* Итерпритатор Python не умеет оптимизировать хвостовую рекурсию, поэтому обычно её заменяют другими механизмами, например циклами или обычной рекурсией
### Lambda
* Анонимная функция - не занимает место в пространстве имен
* Определяется одной строкой без использования ключевого слова `def`, но с помощью `lambda`
* Пример `val = lambda x: x * 2 + 1`
[Go Back](#оглавление)

## Декораторы
[Go Back](#оглавление)
* https://habr.com/ru/articles/141411/
* https://habr.com/ru/articles/141501/
* Декоратор - паттерн проектирования, когда один объект изменяет поведение другого
* Декоратором может быть любой вызываемый объект: функция, лямбда, класс, экземпляр класса. В последнем случае определите метод `__call__`
### Популярные дефолтные декораторы
* @classmethod
* @staticmethod
* @property
## Исключения
[Go Back](#оглавление)

## ООП
[Go Back](#оглавление)
### магические методы
### наследование
## Дескрипторы
[Go Back](#оглавление)

## Метаклассы
[Go Back](#оглавление)
* Метаклассы - классы, создающие классы
* `type` - это метакласс, который Питон внутренне использует для создания всех классов
## Память (сборщик мусора)
[Go Back](#оглавление)

## Gil
[Go Back](#оглавление)

## Модули/пакеты
[Go Back](#оглавление)

## Итерпритатор
[Go Back](#оглавление)

## Либы 
(async, pandas, numpy, pytest, django)
[Go Back](#оглавление)

## Линтеры и аннотация типов 
(pep8)
[Go Back](#оглавление)

## Источники
[Go Back](#оглавление)
* https://github.com/yakimka/python_interview_questions/blob/master/questions.md/#Python
* https://habr.com/ru/companies/ruvds/articles/747084/
